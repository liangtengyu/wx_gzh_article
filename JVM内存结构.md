hello 我是宝哥 , 接上一篇文章,我们聊到了

[JVM加载类的流程](https://mp.weixin.qq.com/s/waSEkKlpG4dE-4SKbt3uIw)

有面试官会让你解释一下Java的内存模型，有些人解释对了，结果面试官说不对，应该是堆啊、栈啊、方法区什么的（遇到这种面试官,就是你装逼的时刻了..）

看完本篇文章你将了解:
- 1.JVM内存结构
- 2.JVM栈帧剖析
- 3.方法区在JDK1.7和1.8中的区别
- 4.堆分代结构

建议收藏!

[toc]



## JVM内存结构
首先`JVM内存结构`和`JAVA内存模型`是两个概念.

### JVM内存结构:


![](https://imgkr2.cn-bj.ufileos.com/80fb539b-55a6-41ab-a310-2ee0008f4e48.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=1JCdN4gNwPax3cgdRaRdQ9YhBjo%253D&Expires=1615345046)

Class文件通过类加载机制 加载到内存空间,`JVM内存结构`就是上图中内存空间，Java内存模型，则是另外的一个概念. 

>根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。

![](https://imgkr2.cn-bj.ufileos.com/041c3924-9e12-4541-a9fa-62ec3a6cdb76.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=8xHAWMc4Hsdt4DglkKQSr7hKnXs%253D&Expires=1615354986)
从上图可看出,运行时数据区分为`五大区域`。这些区域各有各的用途,其中方法区和堆是所有`线程共享`的，栈，本地方法栈和程序计数器则为`线程私有`的。




## 1.程序计数器
>程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。

为什么要程序计数器呢

因为CPU会在多个线程中切换上下文,需要使用程序计数器`纪录当前线程运行到哪一行了`,等待线程重新获取到运行时间时,继续`从计数的位置往下执行`.至于它是线程私有的,是因为每个线程都需要独立计数,各个线程之间不会产生影响.

`面试题:程序计数器会发生OutOfMemoryError吗?`

答:这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native方法，那么计数器为空。

## 2.Java栈（JVM线程栈）
首先我们要记住,栈描述的是方法执行的内存模型,它是线程私有的.
>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程,如下图:


![](https://imgkr2.cn-bj.ufileos.com/d0a55166-f722-4e58-89f4-d85b17c0f6ea.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=zYQB9GcPTS9TsCWBmAm7lWuz2hA%253D&Expires=1615355992)



`面试题:Java虚拟机栈可能出现哪两种类型的异常?`

- 1 虚拟机栈是一个栈,当我们的栈帧超过最大深度时,会抛出StackOverflowError
- 2 栈无法申请到足够的空间时，抛出OutOfMemoryError异常


### 栈帧(Stack Frame)
每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程,那么一个栈帧包含什么?

- `局部变量表(Local Variable Table)`
也叫`本地变量表`,它所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变,它的最小单位为`Slot`,一个Slot可以存放一个`32位以内的数据类型`.虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从`0~局部变量表最大容量`。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会`使用两个连续的Slot`来存储
- `操作数栈(Operand Stack)`
也常称为`操作栈`，它是一个后入先出栈(LIFO)。当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。
- `动态连接(Dynamic Linking)`
在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。
Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。
这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为`静态解析`。另一部分将在每次运行期间转化为直接引用，这类转化称为`动态连接`。
- `方法返回地址(Return address)`
  一般方法执行时,有2种方式会退出该方法
   * 1.`正常退出`
      正常退出指方法正常完成并退出，没有抛出任何异常,当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者`(调用它的方法)`，或者无返回值`(void)`。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。
   * 2.`异常退出`
      方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出,只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出。
      

   方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。
  一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息   

- `附加信息`
指的是在虚拟机实现中加入了一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息。

## 本地方法栈
>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。

java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了.

## 堆
>它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，现在收集器常使用分代算法进行垃圾回收,这里是垃圾回收重灾区.

### 堆分代结构
堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。

新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。它们的默认比例关系如下图:
![](https://static01.imgkr.com/temp/9005de7e31a94d7cad4482e66bcc6498.png)

- `新生代 (Young Generation)`
 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中常规应用进行一次垃圾收集一般可以回收70％～95％的空间，回收效率很高
- `幸存者区 (Survivor)`
  幸存者区有2块, From Survivor区， To Survivor区,也称S0,S1区.被面试官问了不要懵,GC进行时，Eden区中所有存活的对象都会被复制到 To Survivor区，而在FromSurvivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值(默认为15，新生代中的对象毎熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的 header中)的对象会被移到老年代中，没有达到阀值的对象会被复制到 To Survivor区。接着清空Eden区和 From Survivor区，新生代中存活的对象都在 To Survivor区。接着，From Survivor区和 To Survivor区会交换它们的角色,GC时当 To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中.
  
- `老年代(Old)`
在新生代中经历了多次(具体看虚拟机配置的值)GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢
  

---
常见面试题:

- `何时发生Minor GC/Young GC ? `
新生成的对象在Eden区分配(大对象除外，大对象直接进入老年代)，当Eden区没有足够的空间进行分配时，虚拟机将发起一次 `Minor GC`也叫`Young GC`


- `为什么分代？`
  将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率。针对分类进行不同的垃圾回收算法，对算法扬长避短



## 方法区

![](https://imgkr2.cn-bj.ufileos.com/e5b82fe4-288e-4c7b-a0aa-dabab17b2b8c.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=k0G3DS3oNIjjiUo%252FtjlqG2OdGg0%253D&Expires=1615359161)
从这张图可以看到JDK1.8和JDK1.7相比最大的区别是：`元空间区取代了永久代`，永久代原本主要存放`Class`和`Meta`的信息。而元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：`元空间并不在虚拟机中，而是使用本地内存`。因此，默认情况下，元空间的大小仅受本地内存限制。

上图中我们可以看到,JDK1.7和1.8对于运行时数据区和堆中的方法区都做了调整,jdk8中引入了一个新的内存区域叫metaspace。并不是所有的jvm中都有永久代，IBM的J9，oracle的JRocket都没有永久代，永久代是实现层面的东西，永久代里面存的东西基本上就是方法区规定的那些东西。

---

`面试题`: 方法区、永久代、元空间的区别?
- `方法区`：
  是JVM的规范，所有虚拟机必须遵守的。是JVM 所有线程共享的、用于存储类的信息、常量池、方法数据、方法代码等。
- `永久代`:
  全称Permanent Generation space ，是指内存的永久保存区域。是 HotSpot 虚拟机`基于JVM规范`对方法区的一个落地实现，并且只有 HotSpot 才有 PermGen space,在JDK8被移除了.
- `元空间`:
  元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。它也是`基于JVM规范`对方法区的一个落地实现

JDK6、JDK7 时，方法区 就是 PermGen（永久代）。
JDK8 时，方法区就是 Metaspace（元空间）

在`不同版本的JDK中` 堆溢出的实例:

 


![](https://imgkr2.cn-bj.ufileos.com/de86e29f-0b57-4e61-ace2-2a22acfa3b5e.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=2RiyHe8%252B%252Fv6kTm2fZE6io4rioTE%253D&Expires=1615361734)



![](https://imgkr2.cn-bj.ufileos.com/c333f4c7-8ce0-49fb-8157-53760cffd309.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=1DIs0jM5xlCSLE%252BBMFxkjjiJh2g%253D&Expires=1615361746)

---

`面试题`:为什么去除了永久代:

1）字符串存在永久代中，容易出现性能问题和内存溢出。

2）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

3）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

## 结语

经过本篇学习,我们已经知道JVM对于内存的管理,以及它的结构,

千万不要搞混 JVM运行时数据区和JMM(Java memory modle)的关系

而JAVA对象布局在我的一篇文章中有讲过他们是不同的概念
[JAVA对象布局](https://mp.weixin.qq.com/s/0eSiHchlOHAZSAGAchkWmA)

下一篇我们来研究JMM(java的内存模型)和Java中的逃逸分析,以及多线程编程延伸.
请持续关注公众号:`JAVA宝典`