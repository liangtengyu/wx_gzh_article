

## 1.并发和并行

### 举个例子

并发(concurrency):并发的关键在于有处理多个任务的能力,但并不一定就是同时处理.

> 例1:  吃饭时,电话响起,暂时停下吃饭的动作,接完电话后继续吃饭.
>
> 例2:  一个人吃3个馒头

并行(parallelism):并行的关键在于同时处理多个任务

> 例子1: 吃饭时,电话响起,同时进行吃饭和电话2个动作
>
> 例子2: 三个人吃3个馒头

### “并发”指的是程序的结构，“并行”指的是程序运行时的状态

即使不看详细解释，也请记住这句话.

### 并行（parallelism）

这个概念很好理解。所谓并行，就是**同时执行**的意思，无需过度解读。判断程序是否处于并行的**状态**，就看同一时刻是否有超过一个“工作单位”在运行就好了。所以，**单线程永远无法达到并行状态**。

要达到并行状态，最简单的就是利用`多线程`和`多进程`。

注意: Python 的多线程由于存在著名的 GIL(`通俗理解为就是一把全局排他锁`)，无法让两个线程真正“同时运行”，所以实际上是无法到达并行状态的。

### 并发（concurrency）

要理解“并发”这个概念，必须得清楚，**并发指的是程序的“结构”**。当我们说这个程序是并发的，实际上，这句话应当表述成“这个程序采用了支持并发的设计”。好，既然并发指的是人为设计的结构，那么怎样的程序结构才叫做支持并发的设计？

正确的并发设计的标准是：**两个任务可以在重叠的时间段内启动、运行和完成(two tasks can start, run, and complete in overlapping time periods)**。

### 并发 并行 区分的关键:

是否是同时处理多个任务



## 2.同步和异步

- 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。
- 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

### 区分的关键

同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)



## 3.阻塞与非阻塞

- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

### 区分的关键

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的**状态**.





> “阻塞”与"非阻塞"  与  "同步"与“异步"不能简单的从字面理解
> 前者关注的是等待结果时的状态,后者关注的是通信机制